/*
Copyright (C) 2012 Mathias Eitz and Ronald Richter.
All rights reserved.

This file is part of the imdb library and is made available under
the terms of the BSD license (see the LICENSE file).
*/

#ifndef TYPE_NAMES_HPP
#define TYPE_NAMES_HPP

#include <vector>
#include <map>
#include <set>
#include <utility>
#include <complex>
#include <string>

#include <boost/type_traits.hpp>
#include <boost/cstdint.hpp>
#include <boost/static_assert.hpp>


namespace imdb
{

template <class T> struct type_name
{
    // In case you are getting the following error message when compiling:
    // error: invalid application of 'sizeof' to incomplete type 'boost::STATIC_ASSERTION_FAILURE<false>'
    // this means that the compile time assertion below holds and you are most probably trying to serialize
    // a type for which no unique string identifier can be generated by the code in this file.
    // Use the macro DEF_TYPE_NAME to generate a unique name for your class/struct.
    BOOST_STATIC_ASSERT(sizeof(T) == 0);
};

template <class T, class U> struct type_name<std::vector<T, U> >
{
    std::string name() const
    {
        return std::string("std::vector<") + type_name<T>().name() + ">";
    }
};

template <class T> struct type_name<std::complex<T> >
{
    std::string name() const
    {
        return std::string("std::complex<") + type_name<T>().name() + ">";
    }
};


template <class T> struct type_name<std::set<T> >
{
    std::string name() const
    {
        return std::string("std::set<") + type_name<T>().name() + ">";
    }
};


template <class T, class U> struct type_name<std::pair<T, U> >
{
    std::string name() const
    {
        return std::string("std::pair<") + type_name<T>().name() + "," + type_name<U>().name() + ">";
    }
};

template <class T, class U> struct type_name<std::map<T, U> >
{
    std::string name() const
    {
        return std::string("std::map<") + type_name<T>().name() + "," + type_name<U>().name() + ">";
    }
};


#define DEF_TYPE_WITH_NAME(t, n) template<> struct type_name<t> { std::string name() const { return #n; } };
#define DEF_TYPE_NAME(t) DEF_TYPE_WITH_NAME(t, t)

DEF_TYPE_NAME(float)
DEF_TYPE_NAME(double)

DEF_TYPE_NAME(int64_t)
DEF_TYPE_NAME(int32_t)
DEF_TYPE_NAME(int16_t)
DEF_TYPE_NAME(int8_t)

// Visual C++ compiler defines unsigned type names differently
#ifdef _MSC_VER 
#define u_int8_t	uint8_t
#define u_int16_t	uint16_t
#define u_int32_t	uint32_t
#define u_int64_t	uint64_t
#endif

DEF_TYPE_NAME(u_int64_t)
DEF_TYPE_NAME(u_int32_t)
DEF_TYPE_NAME(u_int16_t)
DEF_TYPE_NAME(u_int8_t)

DEF_TYPE_NAME(bool)
DEF_TYPE_NAME(char)
DEF_TYPE_NAME(std::string)

template <class T> inline std::string nameof(T = T())
{
    return type_name<T>().name();
}

} // namespace imdb

#endif // TYPE_NAMES_HPP
