/*
Copyright (C) 2012 Mathias Eitz and Ronald Richter.
All rights reserved.

This file is part of the imdb library and is made available under
the terms of the BSD license (see the LICENSE file).
*/

#ifndef PROPERTY_HPP
#define PROPERTY_HPP

#include <fstream>
#include <stdexcept>
#include <iostream>

#include <boost/iterator/iterator_facade.hpp>
#include <boost/utility.hpp>

#include "types.hpp"
#include "io.hpp"
#include "type_names.hpp"


namespace imdb {

/**
 * @addtogroup io
 * @{
 */


/**
 * @brief Class for reading a property file generated by PropertyWriterT.
 *
 * Property files are vector-like files, comparable to a std::vector<T>. PropertyReaderT
 * opens such files and gives you efficient random access to single elements T. PropertyReaderT
 * supports all element types T that are implemented in imdb::io as well as arbitrary nestings of those.
 *
 * You are responsible for matching T to the type you used when writing the file. No internal checks
 * are made to avoid mismatches: in that case reading either fails or you will read garbage.
 */
template <class T>
class PropertyReaderT : public boost::noncopyable
{
public:


    // if you change the internal format, be sure to also adapt the writer
    static int version()
    {
        return 2;
    }


    /// Construct a reader operating on filename.
    /// @throw std::runtime_error in case the file cannot be openend, the file is corrupt or the version does not match
    PropertyReaderT(const std::string& filename)
        : _ifs(filename.c_str(), std::ifstream::binary)
        , _offset(new std::vector<int64_t>())
        , _map(new strmap_t())
    {
        if (!_ifs.is_open()) throw std::runtime_error("could not open file " + filename);

        _ifs.seekg(-static_cast<int>(sizeof(int64_t)), std::ios::end);
        int64_t p_map;
        io::read(_ifs, p_map);

        _ifs.seekg(p_map);
        if (!_ifs.good()) throw std::runtime_error("error while reading file " + filename);
        io::read(_ifs, *_map);



        if (!_map->count("__version"))
        {
            throw std::runtime_error("error while reading map in file " + filename);
        }

        int p_version  = boost::lexical_cast<int>((*_map)["__version"]);
        bool ignore_type_info = false;
        if (p_version != version())
        {

            // backwards compatibility with version 1 which did not yet have the __typeinfo data
            if (p_version == 1)
            {
                ignore_type_info = true;
                std::cerr << "PropertyReaderT: warning, file '" << filename << "' has old version 1, ignoring type info." << std::endl;
            }
            else
            {
                throw std::runtime_error("version of file " + filename + " is different from program version");
            }
        }


        if (!ignore_type_info)
        {
            if (!_map->count("__typeinfo"))
            {
                throw std::runtime_error("error while reading map in file " + filename + "; map does not contain a __typeinfo entry.");
            }
        }


        if (!_map->count("__features") || !_map->count("__offsets"))
        {
            throw std::runtime_error("error while reading map in file " + filename);
        }

        int64_t p_features = boost::lexical_cast<int64_t>((*_map)["__features"]);
        int64_t p_offsets  = boost::lexical_cast<int64_t>((*_map)["__offsets"]);



        // backwards compatibility to version 1
        if (!ignore_type_info)
        {
            string  p_typeinfo = (*_map)["__typeinfo"];
            string  t_typeinfo = nameof<T>();
            if (p_typeinfo != t_typeinfo)
            {
                throw std::runtime_error("error: elements stored in property file " + filename + " are of type " + p_typeinfo + ". You are trying to read elements of type " + t_typeinfo);
            }
        }

        _ifs.seekg(p_offsets);
        if (!_ifs.good()) throw std::runtime_error("error while reading file " + filename);
        io::read(_ifs, *_offset);

        if (!_ifs.good()) throw std::runtime_error("error while reading file " + filename);

        _p_features = p_features;
    }

    /// Random access into the file, reading the element at position index
    void get(T& r, index_t index) const
    {
        int64_t p = _p_features + (*_offset)[index];
        if (p != _ifs.tellg()) _ifs.seekg(p);
        io::read(_ifs, r);
        assert(_ifs.good());
    }


    /// Convenience array-style random access, returning the element at position index
    T operator[] (index_t index) const
    {
        T r;
        get(r, index);
        return r;
    }


    // iterators
    class const_iterator : public boost::iterator_facade<const_iterator, T const, std::random_access_iterator_tag>
    {
    public:

        const_iterator() : _reader(0), _index(0), _isvalid(false) {}

    private:

        const_iterator(const PropertyReaderT& reader, index_t index)
            : _reader(&reader)
            , _index(index)
            , _isvalid(false)
        {}

        friend class boost::iterator_core_access;
        friend class PropertyReaderT;

        void increment() { _index++; _isvalid = false; }
        void decrement() { _index--; _isvalid = false; }
        void advance(index_t n) { _index += n; _isvalid = false; }

        index_t distance_to(const const_iterator& other) const
        {
            return other._index - _index;
        }

        bool equal(const const_iterator& other) const
        {
            return (_reader == other._reader && _index == other._index);
        }

        const T& dereference() const
        {
            assert(_reader != 0);

            if (!_isvalid)
            {
                _reader->get(_current, _index);
                _isvalid = true;
            }

            return _current;
        }

        const PropertyReaderT* _reader;
        index_t                _index;
        mutable T              _current;
        mutable bool           _isvalid;
    };

    const_iterator begin() { return const_iterator(*this, 0); }
    const_iterator end() { return const_iterator(*this, this->size()); }

    // Note: the results needs to be an index_t as this
    // is fixed to be a 64 bit int independent of the system architecture
    index_t size() const
    {
        return _offset->size();
    }

    const strmap_t& map() const
    {
        return *_map;
    }

private:

    mutable std::ifstream                    _ifs;
    boost::shared_ptr<std::vector<int64_t> > _offset;
    boost::shared_ptr<strmap_t>              _map;
    int64_t                                  _p_features;
};


/**
 * @brief Convenience function to read in a complete property file at once. Make sure that the file you
 * are trying to read is smaller than your available main memory.
 */
template <class T>
void read_property(std::vector<T>& v, const std::string& filename)
{
    PropertyReaderT<T> rd(filename);
    v.resize(rd.size());
    for (index_t i = 0; i < rd.size(); i++) rd.get(v[i], i);
}


/** @} */

} // namespace imdb

#endif // PROPERTY_HPP
